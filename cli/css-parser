#!/usr/bin/env php
<?php

use TBela\CSS\Cli\Args;
use TBela\CSS\Cli\Exceptions\MissingParameterException;
use TBela\CSS\Parser;
use TBela\CSS\Renderer;

require __DIR__ . '/../vendor/autoload.php';

// only use from the cli
if (php_sapi_name() != 'cli') {

    fwrite(STDERR, 'this program must be executed from the cli');
    exit(1);
}

spl_autoload_register(function ($name) {

    $parts = explode('\\', $name);

    if ($parts[0] == 'TBela' && isset($parts[1]) && $parts[1] == 'CSS') {

        array_splice($parts, 0, 2);
        array_unshift($parts, 'src');
    }

    $path = __DIR__ . '/../' . implode('/', $parts) . '.php';

    if (is_file($path)) {

        require($path);
    }
});

$exe = basename($argv[0]);
$cli = new Args($argv);

try {

    $cli->
    setStrict(true)->
    add('version', 'print version number', 'bool', 'v', multiple: false);
    // --data-src="%s" --data-position-index=%s --data-position-line=%s --data-position-column=%s
    $cli->addGroup('internal', "internal commands are used by the multithreading feature:\n", true);
    $cli->add('parse-ast-src', 'src value of the ast nodes', 'string', group: 'internal');
    $cli->add('parse-ast-position-index', 'initial index position of the ast nodes', 'int', group: 'internal');
    $cli->add('parse-ast-position-line', 'initial line number of the ast nodes', 'int', group: 'internal');
    $cli->add('parse-ast-position-column', 'initial column number of the ast nodes', 'int', group: 'internal');

    $cli->addGroup('parse', "parse options:\n");
    $cli->add('capture-errors', 'ignore parse error', 'bool', 'e', multiple: false, group: 'parse');
    $cli->add('flatten-import', 'process @import', 'bool', 'm', multiple: false, group: 'parse');
    $cli->add('parse-allow-duplicate-rules', 'allow duplicate rule', 'bool', 'p', multiple: false, group: 'parse');
    $cli->add('parse-allow-duplicate-declarations', 'allow duplicate declaration', type: 'auto', alias: 'd', multiple: false, group: 'parse');
    $cli->add('file', 'input css file or url', 'string', 'f', multiple: true, group: 'parse');
    $cli->add('parse-multi-processing', 'enable multi-process parser', 'bool', 'M', multiple: false, defaultValue: true, group: 'parse');
    $cli->add('parse-children-process', 'maximum children process', 'int', 'P', multiple: false, defaultValue: 20, group: 'parse');

    $cli->addGroup('render', "render options:\n");
    $cli->add('css-level', 'css color module', 'int', 'l', multiple: false, defaultValue: 4, options: [3, 4], group: 'render');
    $cli->add('charset', 'remove @charset', 'bool', 'S', multiple: false, defaultValue: true, group: 'render');
    $cli->add('compress', 'minify output', 'bool', 'c', multiple: false, group: 'render');
    $cli->add('sourcemap', 'generate sourcemap', 'bool', 's', multiple: false, dependsOn: 'file', group: 'render');
    $cli->add('remove-comments', 'remove comments', 'bool', 'C', multiple: false, group: 'render');
    $cli->add('preserve-license', 'preserve license comments', 'bool', 'L', multiple: false, group: 'render');
    $cli->add('legacy-rendering', 'legacy rendering', 'bool', 'G', multiple: false, group: 'render');
    $cli->add('compute-shorthand', 'compute shorthand properties', 'bool', 'u', multiple: false, group: 'render');
    $cli->add('remove-empty-nodes', 'remove empty nodes', 'bool', 'E', multiple: false, group: 'render');
    $cli->add('render-duplicate-declarations', 'render duplicate declarations', 'bool', 'r', multiple: false, group: 'render');
    $cli->add('output', 'output file name', 'string', 'o', multiple: false, group: 'render');
    $cli->add('ast', 'dump ast as JSON', 'bool', 'a', multiple: false, group: 'render');
    $cli->add('output-format', 'ast export format', 'string', 'F', multiple: false, options: ['json', 'serialize'], dependsOn: 'ast', group: 'render');

    $cli->parse();

    $parseOptions = [];
    $renderOptions = [];

    $groups = $cli->getGroups();
    $args = $cli->getArguments();

    if (isset($args['version'])) {

        $data = json_decode(file_get_contents(__DIR__.'/../package.json'), JSON_OBJECT_AS_ARRAY);
        $metadata = json_decode(file_get_contents(__DIR__.'/../composer.json'), JSON_OBJECT_AS_ARRAY);

        echo sprintf("%s (version %s)
Copyright (C) %s %s.
Dual licensed under MIT or LGPL v3\n", $exe, $data['version'], date('Y'), implode(', ', array_map(function ($author) {

        return $author['name'];
        }, $metadata['authors'])));
        exit (0);
    }

    $pipeIn = !posix_isatty(STDIN);
    $pipeOut = !posix_isatty(STDOUT);

    $inFile = $pipeIn ? STDIN : ($args['file'] ?? null);
    $outFile = $pipeOut ? STDOUT : ($args['output'] ?? STDOUT);

    if ($inFile == STDIN) {

        if (!empty($args['file'])) {

            fwrite(STDERR, "> notice: ignoring parameter --file\n");
        }

        if (!empty($args['_'])) {

            fwrite(STDERR, "> notice: ignoring inline css\n");
        }
    }

    if ($outFile == STDOUT && !empty($args['output'])) {

        fwrite(STDERR, "> notice: ignoring parameter --output\n");
    }

    if (isset($args['sourcemap']) && $outFile == STDOUT) {

        throw new InvalidArgumentException(sprintf("%s: --sourcemap requires --file parameter\nTry '%s --help'", $exe, $exe));
    }

    foreach (array_keys($groups['parse']['arguments']) as $key) {

        if (isset($args[$key])) {

            $parseOptions[str_replace(['parse-', '-'], ['', '_'], $key)] = $args[$key];
        }
    }

    foreach (array_keys($groups['render']['arguments']) as $key) {

        if (isset($args[$key])) {

            $renderOptions[str_replace(['render-', '-'], ['', '_'], $key)] = $args[$key];
        }
    }

    foreach (array_keys($groups['internal']['arguments']) as $key) {

        if (isset($args[$key])) {

            if (str_starts_with($key, 'parse-')) {

                $parseOptions[str_replace(['parse-', '-'], ['', '_'], $key)] = $args[$key];
            }

            else if (str_starts_with($key, 'render-')) {

                $renderOptions[str_replace(['render-', '-'], ['', '_'], $key)] = $args[$key];
            }
        }
    }

    $parser = new Parser(options: $parseOptions);

    if ($inFile) {

        if ($inFile == STDIN) {

            $parser->appendContent(file_get_contents('php://stdin'));
        } else {

            foreach ((array)$inFile as $file) {

                $parser->load($file);
            }
        }
    } else if (!empty($args['_'])) {

        $parser->appendContent(implode('', $args['_']));
    } else {

        // no input
        exit(0);
    }

    if ($outFile) {

        if (!empty($args['ast'])) {

            $ast = $parser->getAst();

            if (($args['output-format'] ?? 'json') == 'serialize') {

                $ast = serialize($ast);
            }

            else {

                $ast = json_encode($ast, empty($renderOptions['compress']) ? JSON_PRETTY_PRINT : 0);
            }

            if ($outFile == STDOUT) {

                fwrite($outFile, $ast);
            } else {

                file_put_contents($outFile, $ast);
            }

        } else {

            $renderer = new Renderer($renderOptions);

            if ($outFile == STDOUT) {

                fwrite($outFile, $renderer->renderAst($parser));
            } else {

                $renderer->save($parser, $outFile);
            }
        }
    }
} catch (ValueError|UnexpectedValueException|InvalidArgumentException $e) {

    fwrite(STDERR, $e->getMessage() . "\n");
    exit($e->getCode());
} catch (MissingParameterException $e) {

    fwrite(STDERR, sprintf("%s: %s\nTry '%s --help'\n", $exe, $e->getMessage(), $exe));
    exit($e->getCode());
} catch (Exception $e) {

    fwrite(STDERR, $e->getMessage() . "\n");
    exit(1);
}